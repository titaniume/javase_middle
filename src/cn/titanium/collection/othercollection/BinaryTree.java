package cn.titanium.collection.othercollection;

/**
 * 二叉树
 * @author Administrator
 *2017年10月17日下午6:16:01
 */
public class BinaryTree {
	public static void main(String[] args) {
		
		
		// 1 : 二叉树概念
		/*二叉树由各种节点组成
		二叉树特点：
		每个节点都可以有左子节点，右子节点
		每一个节点都有一个值*/
		
		
		// 2 : 二叉树排序-插入数据
		/*假设通过二叉树对如下10个随机数进行排序
		67,7,30,73,10,0,78,81,10,74
		排序的第一个步骤是把数据插入到该二叉树中
		插入基本逻辑是，小、相同的放左边，大的放右边
		1. 67 放在根节点
		2. 7 比 67小，放在67的左节点
		3. 30 比67 小，找到67的左节点7，30比7大，就放在7的右节点
		4. 73 比67大， 放在67得右节点
		5. 10 比 67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，放在30的左节点。
				...
		...
		9. 10比67小，找到67的左节点7，10比7大，找到7的右节点30，10比30小，找到30的左节点10，10和10一样大，放在左边
		*/
		
		
		//3 : 二叉树排序-遍历
		/*通过上一个步骤的插入行为，实际上，数据就已经排好序了。 接下来要做的是看，把这些已经排好序的数据，遍历成我们常用的List或者数组的形式

		二叉树的遍历分左序，中序，右序
		左序即： 中间的数遍历后放在左边
		中序即： 中间的数遍历后放在中间
		右序即： 中间的数遍历后放在右边*/
		
		
		//4 : 练习-英雄二叉树     
		/*根据上面的学习和理解，设计一个Hero二叉树，HeroNode. 
		可以向这个英雄二叉树插入不同的Hero对象，并且按照Hero的血量倒排序。

		随机生成10个Hero对象，每个Hero对象都有不同的血量值，插入这个HeroNode后，把排序结果打印出来。*/
		
		
		// 6 : 练习-比较冒泡法，选择法以及二叉树排序的性能区别
		/*创建4万个随机数，然后用分别用冒泡法，选择法，二叉树3种排序算法进行排序，比较哪种更快*/
	}
}
