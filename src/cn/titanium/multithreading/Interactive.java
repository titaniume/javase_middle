package cn.titanium.multithreading;

/**
 * 交互
 * @author Administrator
 *2017年10月20日下午12:50:54
 */
public class Interactive {
	
	public static void main(String[] args) {
		
	/*	线程之间有交互通知的需求，考虑如下情况： 
		有两个线程，处理同一个英雄。 
		一个加血，一个减血。 

		减血的线程，发现血量=1，就停止减血，直到加血的线程为英雄加了血，才可以继续减血*/
		
		// 1 : 不好的解决方式
		/*故意设计减血线程频率更高，盖伦的血量迟早会到达1
		减血线程中使用while循环判断是否是1，如果是1就不停的循环,直到加血线程回复了血量
		这是不好的解决方式，因为会大量占用CPU,拖慢性能*/
		
		// 2 : 使用wait和notify进行线程交互
	
		//3 : 关于wait、notify和notifyAll
		//留意wait()和notify() 这两个方法是什么对象上的？
	/*	public synchronized void hurt() {
			  。。。
			  this.wait();
			  。。。
			}
			 

			 
			public synchronized void recover() {
			   。。。
			   this.notify();
			}
			 


			这里需要强调的是，wait方法和notify方法，并不是Thread线程上的方法，它们是Object上的方法。 

			因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。

			wait()的意思是： 让占用了这个同步对象的线程，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。

			notify() 的意思是，通知一个等待在这个同步对象上的线程，你可以苏醒过来了，有机会重新占用当前对象了。

			notifyAll() 的意思是，通知所有的等待在这个同步对象上的线程，你们可以苏醒过来了，有机会重新占用当前对象了*/
	
		// 4 : 练习-线程交互
		/*假设加血线程运行得更加频繁，英雄的最大血量是1000

		设计加血线程和减血线程的交互，让回血回满之后，加血线程等待，直到有减血线程减血*/
		
		
		//5 : 练习-多线程交互
		/*在上面的练习的基础上，增加回血线程到2条，减血线程到5条，同时运行。

		运行一段时间，观察会发生的错误，分析错误原因，并考虑解决办法*/
	
		//练习-生产者消费者问题
	}
}
